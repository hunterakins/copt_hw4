# -*- coding: utf-8 -*-
"""cse203b23_hw4_gd_assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nvwWug_eowcAf4HrznlTm4YhcBJuokgc
"""


# @title 3d plotting
import scprep
import matplotlib.pyplot as plt # plotting
from mpl_toolkits.mplot3d import Axes3D

def network_plot_3D(G, angle=0.0, save=False, colors=None):
    # Get node positions
    pos = nx.get_node_attributes(G, 'pos')
    # Get number of nodes
    n = G.number_of_nodes()
    # Get the maximum number of edges adjacent to a single node
    edge_max = max([G.degree(i) for i in range(n)])
    # Define color range proportional to number of edges adjacent to a single node
    #colors = [plt.cm.plasma(G.degree(i)/edge_max) for i in range(n)] 

    # 3D network plot
    print('hi')
    #with plt.style.context(('ggplot')):
    
    fig = plt.figure(figsize=(10,7))
    ax = Axes3D(fig)
    
    # Loop on the pos dictionary to extract the x,y,z coordinates of each node
    for key, value in pos.items():
        xi = value[0]
        yi = value[1]
        zi = value[2]
        
        # Scatter plot
        #ax.scatter(xi, yi, zi, c=colors[key], s=20+20*G.degree(key), edgecolors='k', alpha=0.7)
        if colors is not None:
          ax.scatter(xi, yi, zi, c=["gray","black"][colors[key]], s=20+20*G.degree(key), edgecolors='k', alpha=0.7)
        else:
          ax.scatter(xi, yi, zi, c="gray", s=20+20*G.degree(key), edgecolors='k', alpha=0.7)
    
    # Loop on the list of edges to get the x,y,z, coordinates of the connected nodes
    # Those two points are the extrema of the line to be plotted
    for i,j in enumerate(G.edges()):
        x = np.array((pos[j[0]][0], pos[j[1]][0]))
        y = np.array((pos[j[0]][1], pos[j[1]][1]))
        z = np.array((pos[j[0]][2], pos[j[1]][2]))
    
    # Plot the connecting lines
        ax.plot(x, y, z, c='black', alpha=0.5)
    #print('done looping')
    
    # Set the initial view
    ax.view_init(30, angle)
    # Hide the axes
    #ax.set_axis_off()
    if save is not False:
        plt.savefig("plot.png")
        plt.close('all')
    else:
        print('showing')
        plt.show()
    return

"""imports and utilities """
import networkx as nx # graphs
import numpy as np # linear algebra
import cvxpy as cp # convex optimization

import random

def dict_to_arr(A):
    idx = np.array(list(A.keys()))
    val = np.array(list(A.values()))

    n = idx.max(0)+1
    out = np.zeros_like(val)
    out[idx] = val
    return out

"""generate graph and get positions. If you change these settings, 
make sure to change to change them back when submitting """
n = 100 # number of vertices
m = 3 # dimension to embed each vertex in R^m
p = 0.3
seed = 896803
np.random.seed(seed=seed)
n_fixed = 20 # number of fixed vertices
n_free = n - n_fixed

# generate a random geometric graph
G = nx.random_geometric_graph(n, p, seed=seed, dim=3)

# position is stored as node attribute data for random_geometric_graph
pos = nx.get_node_attributes(G, "pos")
c = np.array([x for x in pos.values()]).mean(0)
pos = dict([(k, v - c) for k,v in pos.items()])
nx.set_node_attributes(G, pos, name="pos")

"""graph laplacian and ground-truth positions (centered) """
X = X0 = dict_to_arr(pos)
L = nx.laplacian_matrix(G).todense()

"""sample fixed nodes """
random_node_indices = np.random.choice(np.arange(n),n_fixed,replace=False)
fixed_mask = np.zeros(n, bool)
fixed_mask[random_node_indices] = 1
free_mask = ~fixed_mask

"""plot ground truth. black vertices are fixed. """
network_plot_3D(G, angle=15.0, colors=fixed_mask, save=False)

"""generate problem parameters: FILL THIS IN """
"""projection matrix """
P1 = np.identity(n) - np.outer(np.ones(n), np.ones(n)) / n
Ltilde = P1.T @ L @ P1
Ltilde11 = Ltilde[fixed_mask,:][:, fixed_mask]
Ltilde12 = Ltilde[fixed_mask,:][:, free_mask]
Ltilde21 = Ltilde[free_mask,:][:, fixed_mask]
Ltilde22 = Ltilde[free_mask,:][:, free_mask]
XL = X[fixed_mask]
print('xl fixed', XL.shape)
B = XL.T @ Ltilde12
print('B shape', B.shape)
L_free = Ltilde22
s, u = np.linalg.eigh(L_free)
# CVXPY enforces DCP rules: https://www.cvxpy.org/tutorial/dcp/index.html. 
# Will return an error if trace(X^T L X) appears in the objective. Need to re-express as a DCP-valid expression.
# _sqrtm is a hint, but make sure to read/skim the link above.
#def _sqrtm(C):
#    return None
print(s)
L_free_sqrt = u[:,s>1e-9]@np.diag(np.sqrt(s[s>1e-9]))@u[:,s>1e-9].T




"""set up problem: FILL THIS IN. One good choice of r^2 is 10, but think about the proper choice. """
X_var = cp.Variable((n_free, 3))

""" r_sq = m """
delta = np.trace((XL.T@XL))
r_sq = n_free /n_fixed *delta
print('r_sq', r_sq)
alpha = np.trace(XL.T@Ltilde11 @ XL)
#alpha = 0
print('delta', delta)


#def cp_matrix_inner(A, B):
#  return None

prob = cp.Problem(cp.Minimize(alpha + 2*cp.trace(B@X_var) + cp.square(cp.norm(L_free_sqrt@X_var, 'fro'))), [cp.square(cp.norm(X_var, 'fro')) - r_sq + delta <= 0] )

"""you are done! """

"""solve problem """
prob.solve()

"""map back coordinates """
X_sol = np.zeros_like(X)
X_sol[fixed_mask] = X[fixed_mask]
X_sol[free_mask] = X_var.value

"""plot solution: SUBMIT THIS. """
pos = dict([(k, X_sol[k]) for k,v in pos.items()])
nx.set_node_attributes(G, pos, name="pos")
network_plot_3D(G, angle=15.0, colors=fixed_mask, save=False)
network_plot_3D(G, angle=15.0, colors=fixed_mask, save=True)

"""optional animation of vertex embeddings """
#scprep.plot.rotate_scatter3d(X_sol, c=free_mask, cmap="gray", title="optimized vertex embeddings")

print("\nThe optimal value is", prob.value)
print("A solution x is")
print(X_var.value)
print("A dual solution is")
print(prob.constraints[0].dual_value)
